from tns.morphmath import sample
import numpy as np


bifurcation_methods = ['symmetric', 'bio_oriented', 'directional', 'bio_smoothed',]


def init_soma_radius(grower):
    """Generates a soma based on input_distributions.
    The initial neurites need to be generated
    in order to get the soma coordinates correct.
    """
    from tns.core.soma import SomaGrower

    soma_radius = sample.soma_size(grower.input_distributions)

    soma = SomaGrower(initial_point=grower.input_parameters["origin"],
                      radius=soma_radius)

    grower.soma = soma


def _convert_orientation2points(grower, orientation, n_trees, distr):
    '''Checks the type of orientation input
    and returns the soma points generated by the
    corresponding selection. Currently accepted
    orientations include the following options:
    list of 3D points: select the orientation externally
    None: creates a list of orientations according to the biological distributions.
    'from_space': generates orientations depending on spatial input (not implemented yet).
    '''
    error_msg1 = 'Not enough orientation points!'
    error_msg2 = 'Not implemented yet!'
    error_msg3 = 'Input orientation format is not correct!'

    if type(orientation) is list: # Gets major orientations externally
        if len(orientation) >= n_trees:
            pts = grower.soma.add_points_from_orientations(orientation[:n_trees])
        else:
            raise ValueError(error_msg1)
    elif orientation is None: # Samples from trunk_angles
        trunk_angles = sample.trunk_angles(distr, n_trees)
        trunk_z = sample.azimuth_angles(distr, n_trees)
        pts = grower.soma.add_points_from_trunk_angles(trunk_angles, trunk_z)
    elif orientation == 'from_space':
        raise ValueError(error_msg2)
    else:
        raise ValueError(error_msg3)
    return pts


def grow_trunks(grower):
    """Generates the initial points of each tree,
    which depend on the selected tree types and the
    soma surface. All the trees start growing from
    the surface of the soma. The outgrowth direction
    is either specified by the input parameters,
    from the parameters['type']['orientation'] or
    is randomly chosen according to the biological
    distribution of trunks on the soma surface
    if 'orientation' is None.
    """
    from tns.core.tree import TreeGrower
    tree_list = [] # A list of tree with the corresponding orientations
                   # and initial points on the soma surface will be initialized.

    for type_of_tree in grower.input_parameters['grow_types']:

        # Easier to access distributions
        params = grower.input_parameters[type_of_tree]
        distr = grower.input_distributions[type_of_tree]

        # Sample the number of trees depending on the tree type
        n_trees = sample.n_neurites(distr["num_trees"])
        orientation = params['orientation']
        # Clean up orientation options in converting function
        points = _convert_orientation2points(grower, orientation, n_trees, distr)

        # Iterate over all initial points on the soma and create new trees
        # with a direction and initial_point
        for p in points:
            tree_direction = grower.soma.orientation_from_point(p)
            tree_list.append(TreeGrower(grower.neuron,
                                        initial_direction=tree_direction,
                                        initial_point=p,
                                        parameters=params,
                                        distributions=distr))

    grower.trunks = tree_list


def grow_soma(grower, interpolation=None):
    """Generates a soma based on input_distributions.
    The initial neurites need to be generated
    in order to get the soma coordinates correct.
    """
    init_soma_radius(grower)
    grow_trunks(grower)
    soma_points = grower.soma.generate_neuron_soma_points3D(interpolation=interpolation)
    grower.neuron.add_points_without_radius(points3D=soma_points, radius=0.0)
    grower.neuron.add_group([0, 1, -1])


def grow_neurite(grower, tree):
    """Grows the corresponding tree and registers the results
    in the neuron of the grower.
    """
    from tns.basic import neurite_types
    from tns.morphmath.rotation import angle3D

    tree_type = neurite_types[tree.type]
    params = grower.input_parameters[tree_type]
    distrs = grower.input_distributions[tree_type]
    method = params["branching_method"]

    assert method in bifurcation_methods, \
        'Method not recognized, please select one of: ' + ', '.join(bifurcation_methods) + ' !'

    ph = sample.ph(distrs["ph"])

    if  tree_type != "apical":
        tree.generate_ph_angles(ph_angles=ph, method=method)
    else:
        tree.generate_ph_apical(ph_angles=ph, method=method)
